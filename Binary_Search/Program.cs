///Бинарный поиск — классический алгоритм. На вход алгоритм принимает отсортированный массив чисел и число для поиска. 
///На выходе — индекс этого числа в массиве.
///Алгоритмически это выглядит так:
///Запоминаем левую L и правую R границы массива (индексы, а не значения)
///Берем индекс M посередине между L и R
///Если значение массива по индексу M меньше нужного — L меняем на M, если больше — R меняем на M
///Возвращаемся на шаг 2
///Таким образом мы на каждом шаге алгоритма сужаем область поиска в 2 раза. Этот алгоритм имеет сложность O(log(n)).
///
///на вход программы поступает какое-то упорядоченное множество и искомое значение
///на выход:  либо значение ключа в множестве, либо -1, если в множестве нет искомого ключа

using System;

namespace Binary_Search
{
    class Program
    {
        static void Main(string[] args)
        {
            int[] sortedArray = { 0,1,2,3,4,5,9,15,16,24};
            Console.WriteLine(Search(sortedArray, 9));
            Console.ReadLine();
        }
        public static int Search<T>(T[] data, T value) where T : IComparable
        {
            var left = data.GetLowerBound(0); //левый индекс
            var right = data.GetUpperBound(0); //правый индекс
            //а здесь можно было бы добавить проверку на слишком большой и малекий объект велью, которые явно меньше и больше значений массива
            if (left == right)
                return left; //с таким же успехом могли взять и right
            while (true)
            {
                if (right - left == 1) //ситуация, когда интервал свелся к двум соседним индексам (к примеру 3-ий и 4-ый L_R)
                {
                    if (data[left].CompareTo(value) == 0)
                        return left; //и либо это левый индекс
                    if (data[right].CompareTo(value) == 0)
                        return right; //либо ответ в правом индексе
                    return -1; //в противном случае нет ответа
                }
                else
                {
                    var middle = left + (right - left) / 2; //таким образом избегаем переполнения типо. Ищем середину индексов
                    var comparisonResult = data[middle].CompareTo(value); // Сравниваем искомый экземпляр со значением, которое находится в индексе центра
                                                                          // L______M______R 
                    if (comparisonResult == 0) //если они совпадают, то возращаем этот ключ - он и есть результат поиска
                        return middle;
                    if (comparisonResult < 0) //если значение меньше, то индекс середины присваивается левому краю (отрезается половина M_____R)
                        left = middle;
                    if (comparisonResult > 0) //в противном случае индекс присваивается правой границу (отрезается половина справа      L______M)
                        right = middle;
                }
            }
        }

    }
}
